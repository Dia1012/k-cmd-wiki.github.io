# 스코어보드 ID 시스템
<hr>

커맨드나 데이터팩을 개발하다 보면 여러 엔티티들 중 스코어 값이 같은 엔티티를 감지하고 싶을 때가 있다. 그게 언젠지는 따로 말 안 하겠다. 필요한 사람은 봐라.

그러나 기존의 `if score`에서, 첫 번째 대상은 `execute as`와 `@s`를 이용한다 쳐도 두 번째 비교 대상은 한 마리만 가능하다. 뭐 랜덤 한마리 조건을 켜고 걸릴 때까지 재귀함수를 돌려버릴 수도 없고 난감하다.

감자가 처음 커맨드를 배울 때 저지른 귀여운(?)실수가 있었다. 그 시절 나는 `execute as @a at @s`를 `execute at @a as @p`로 쓰는 만행을 저질렀다.

여기서 얻게 되는 아이디어가 있다. `@s`뿐만 아니라 위치로도 대상을 지정할 수가 있다! 즉 한 커맨드 안에서 여러 대상을 두 개나 커버할 수 있게 된다.

양들과 크리퍼들 중 스코어가 같은 쌍을 감지해보자.

```mcfunction
execute as 양들 at 크리퍼들 if score @s asdf = @e[limit=1,sort=nearest] asdf run say 감지!
 ```

일반적으로 크리퍼 두 마리가 정확히 동일한 좌표에 있을 일은 없으므로 정상적으로 감지에 성공할 것이다. 감지된 두 엔티티 중 양은 `@s`로, 크리퍼는 `@e[limit=1,sort=nearest]`로 쓰면 된다.

원리는 간단하다. `as`에 의해 '어느 한 양'이 대상으로 정해지고, `at`에 의해 '어느 한 크리퍼'의 위치에서 명령어를 실행한다. 그 위치에서 가장 가까운 엔티티는 '그 크리퍼'이므로 '그 양'과 '그 크리퍼' 둘을 비교하게 된다.

만약 둘의 스코어가 다르다면 '그 양'이라는 대상은 유지된 채로 '또 다른 크리퍼'와 스코어를 비교한다. 이것이 반복된다.

가능한 모든 크리퍼와 비교를 했음에도 스코어가 같은 짝을 찾지 못했다면, 이제 '그 양'이 아닌 다른 양을 주체로 모든 크리퍼와 짝을 찾는 것을 다시 하게 된다. 이렇게 가능한 모든 경우의 수를 일일히 찾는 노가다가 저 한 줄에서 일어나는 것이다.

이해가 안 된다면 맨 하단에서 Towercrain님이 올린 사진을 하나 보자.

그러나 우리의 짖궂은 플레이어들이 대상이라면 코너에 서로 겹치면서 정확히 같은 좌표에 서 버그를 유발하려고 난리를 칠 것이다.

데이터팩 함수를 두 개 이용하면 이러한 위치 문제도 해결할 수 있다. 이전에 등장한 `self`태그를 이용해보자.

```mcfunction
감지함수1
{
tag @s add self
execute as 크리퍼들 run function 감지함수2
tag @s remove self
}
```
```mcfunction
감지함수2
{
execute if score @s asdf = @e[tag=self,limit=1] run say 감지!
}
```

이렇게 함수를 짜고 `execute as 양 run function 감지함수1` 을 하면, 감지함수 1에서 `@s`는 양이므로 양에게 `self`태그가 부여된 채로 크리퍼를 주체로 한 감지함수2가 실행된다.

감지함수2에서는 `@s`가 크리퍼이며, `self`태그는 이전에 감지함수1에서의 주체인 그 양 한 마리만 가지고 있으므로 정상적으로 감지에 성공한다.

감지함수 2에서 크리퍼는 `@s`로, 양은  `@e[tag=self,limit=1]`로 쓰면 된다. 조금만 수정하면 꼭 양과 크리퍼라는 다른 엔티티가 아닌크리퍼들 중 같은 스코어값 가진 둘을 감지하는 것도 쉽다.
